{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/viveks/PycharmProjects/resume-builder/src/lib/parse-resume-from-pdf.ts"],"sourcesContent":["import type { ResumeFormData } from \"./resumeSchema\"\n\ninterface ParsedResume {\n  personalInfo: {\n    fullName: string\n    email: string\n    phone: string\n    location: string\n    linkedIn: string\n    portfolio: string\n  }\n  professionalSummary: string\n  workExperience: Array<{\n    company: string\n    position: string\n    startDate: string\n    endDate: string\n    current: boolean\n    description: string\n  }>\n  education: Array<{\n    institution: string\n    degree: string\n    field: string\n    graduationDate: string\n  }>\n  skills: {\n    technical: string\n    soft: string\n  }\n}\n\n// Extract email from text\nfunction extractEmail(text: string): string {\n  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g\n  const matches = text.match(emailRegex)\n  return matches?.[0] || \"\"\n}\n\n// Extract phone number from text\nfunction extractPhone(text: string): string {\n  const phoneRegex = /(\\+?\\d{1,3}[-.\\s]?)?\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}/g\n  const matches = text.match(phoneRegex)\n  return matches?.[0] || \"\"\n}\n\n// Extract LinkedIn URL\nfunction extractLinkedIn(text: string): string {\n  const linkedInRegex = /(?:https?:\\/\\/)?(?:www\\.)?linkedin\\.com\\/in\\/[\\w-]+/gi\n  const matches = text.match(linkedInRegex)\n  return matches?.[0] || \"\"\n}\n\n// Extract portfolio/website URL\nfunction extractPortfolio(text: string): string {\n  const urlRegex = /(?:https?:\\/\\/)?(?:www\\.)?[a-zA-Z0-9-]+\\.[a-zA-Z]{2,}(?:\\/[^\\s]*)?/gi\n  const matches = text.match(urlRegex)\n  // Filter out LinkedIn and common email domains\n  const filtered = matches?.filter(\n    (url) =>\n      !url.includes(\"linkedin.com\") &&\n      !url.includes(\"@\") &&\n      !url.includes(\"gmail.com\") &&\n      !url.includes(\"yahoo.com\") &&\n      !url.includes(\"outlook.com\")\n  )\n  return filtered?.[0] || \"\"\n}\n\n// Extract name (usually first line or before email)\nfunction extractName(text: string): string {\n  const lines = text.split(\"\\n\").filter((line) => line.trim().length > 0)\n  // Name is usually in the first few lines, before contact info\n  for (let i = 0; i < Math.min(5, lines.length); i++) {\n    const line = lines[i].trim()\n    // Skip if it's clearly an email, phone, or URL\n    if (\n      line.includes(\"@\") ||\n      extractPhone(line) ||\n      line.startsWith(\"http\") ||\n      line.toLowerCase().includes(\"resume\") ||\n      line.toLowerCase().includes(\"cv\")\n    ) {\n      continue\n    }\n    // Name is usually 2-4 words\n    const words = line.split(/\\s+/)\n    if (words.length >= 2 && words.length <= 4) {\n      return line\n    }\n  }\n  return \"\"\n}\n\n// Extract location (look for city, state or country patterns)\nfunction extractLocation(text: string): string {\n  const locationPatterns = [\n    /([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*),\\s*([A-Z]{2})/g, // City, State\n    /([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*),\\s*([A-Z][a-z]+)/g, // City, Country\n  ]\n\n  for (const pattern of locationPatterns) {\n    const matches = text.match(pattern)\n    if (matches && matches.length > 0) {\n      return matches[0]\n    }\n  }\n  return \"\"\n}\n\n// Extract work experience\nfunction extractWorkExperience(text: string): ParsedResume[\"workExperience\"] {\n  const experiences: ParsedResume[\"workExperience\"] = []\n  const lines = text.split(\"\\n\")\n\n  // Common patterns for work experience sections\n  const experienceKeywords = [\n    \"experience\",\n    \"employment\",\n    \"work history\",\n    \"professional experience\",\n    \"career\",\n  ]\n\n  let inExperienceSection = false\n  let currentExperience: Partial<ParsedResume[\"workExperience\"][0]> | null = null\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim()\n    const lowerLine = line.toLowerCase()\n\n    // Detect experience section\n    if (\n      experienceKeywords.some((keyword) => lowerLine.includes(keyword)) &&\n      lowerLine.length < 50\n    ) {\n      inExperienceSection = true\n      continue\n    }\n\n    // Stop if we hit education section\n    if (\n      lowerLine.includes(\"education\") &&\n      lowerLine.length < 50 &&\n      inExperienceSection\n    ) {\n      break\n    }\n\n    if (inExperienceSection && line.length > 0) {\n      // Look for position/company pattern (e.g., \"Software Engineer | Company Name\")\n      const positionCompanyMatch = line.match(/^(.+?)\\s*[|\\-–—]\\s*(.+)$/)\n      if (positionCompanyMatch) {\n        if (currentExperience) {\n          experiences.push(currentExperience as ParsedResume[\"workExperience\"][0])\n        }\n        currentExperience = {\n          position: positionCompanyMatch[1].trim(),\n          company: positionCompanyMatch[2].trim(),\n          startDate: \"\",\n          endDate: \"\",\n          current: false,\n          description: \"\",\n        }\n        continue\n      }\n\n      // Look for date ranges (e.g., \"Jan 2020 - Present\" or \"2020-2023\")\n      const dateRangeMatch = line.match(\n        /(\\d{4}|\\w+\\s+\\d{4})\\s*[-–—]\\s*(Present|Current|\\d{4}|\\w+\\s+\\d{4})/i\n      )\n      if (dateRangeMatch && currentExperience) {\n        currentExperience.startDate = dateRangeMatch[1]\n        const endDate = dateRangeMatch[2]\n        if (endDate.toLowerCase() === \"present\" || endDate.toLowerCase() === \"current\") {\n          currentExperience.current = true\n        } else {\n          currentExperience.endDate = endDate\n        }\n        continue\n      }\n\n      // Collect description lines\n      if (currentExperience && line.length > 20) {\n        currentExperience.description +=\n          (currentExperience.description ? \" \" : \"\") + line\n      }\n    }\n  }\n\n  if (currentExperience) {\n    experiences.push(currentExperience as ParsedResume[\"workExperience\"][0])\n  }\n\n  return experiences.length > 0 ? experiences : []\n}\n\n// Extract education\nfunction extractEducation(text: string): ParsedResume[\"education\"] {\n  const education: ParsedResume[\"education\"] = []\n  const lines = text.split(\"\\n\")\n\n  let inEducationSection = false\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim()\n    const lowerLine = line.toLowerCase()\n\n    if (lowerLine.includes(\"education\") && lowerLine.length < 50) {\n      inEducationSection = true\n      continue\n    }\n\n    // Stop if we hit skills section\n    if (\n      (lowerLine.includes(\"skills\") || lowerLine.includes(\"technical\")) &&\n      lowerLine.length < 50 &&\n      inEducationSection\n    ) {\n      break\n    }\n\n    if (inEducationSection && line.length > 0) {\n      // Look for degree pattern (e.g., \"Bachelor of Science in Computer Science\")\n      const degreeMatch = line.match(\n        /(Bachelor|Master|PhD|Doctorate|Associate|Diploma|Certificate).*?(?:in|of)\\s*(.+?)(?:,|\\s+-\\s+|\\s*$)/i\n      )\n      if (degreeMatch) {\n        const degree = degreeMatch[0].trim()\n        const institution = lines[i + 1]?.trim() || \"\"\n        const dateMatch = text.match(/(\\d{4})/g)\n        const graduationDate = dateMatch?.[dateMatch.length - 1] || \"\"\n\n        education.push({\n          degree,\n          field: degreeMatch[2]?.trim() || \"\",\n          institution,\n          graduationDate,\n        })\n      }\n    }\n  }\n\n  return education.length > 0 ? education : []\n}\n\n// Extract skills\nfunction extractSkills(text: string): ParsedResume[\"skills\"] {\n  const skills: ParsedResume[\"skills\"] = {\n    technical: \"\",\n    soft: \"\",\n  }\n\n  const lines = text.split(\"\\n\")\n  let inSkillsSection = false\n  const technicalKeywords = [\n    \"javascript\",\n    \"python\",\n    \"java\",\n    \"react\",\n    \"node\",\n    \"sql\",\n    \"aws\",\n    \"docker\",\n    \"git\",\n    \"typescript\",\n    \"html\",\n    \"css\",\n    \"mongodb\",\n    \"postgresql\",\n  ]\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim()\n    const lowerLine = line.toLowerCase()\n\n    if (\n      (lowerLine.includes(\"skills\") || lowerLine.includes(\"technical\")) &&\n      lowerLine.length < 50\n    ) {\n      inSkillsSection = true\n      continue\n    }\n\n    if (inSkillsSection && line.length > 0) {\n      // Check if line contains technical skills\n      const hasTechnical = technicalKeywords.some((keyword) =>\n        lowerLine.includes(keyword)\n      )\n\n      if (hasTechnical) {\n        skills.technical += (skills.technical ? \", \" : \"\") + line\n      } else if (line.length > 3) {\n        skills.soft += (skills.soft ? \", \" : \"\") + line\n      }\n    }\n  }\n\n  return skills\n}\n\n// Extract professional summary/objective\nfunction extractProfessionalSummary(text: string): string {\n  const lines = text.split(\"\\n\")\n  const summaryKeywords = [\"summary\", \"objective\", \"profile\", \"about\"]\n\n  for (let i = 0; i < Math.min(20, lines.length); i++) {\n    const line = lines[i].trim()\n    const lowerLine = line.toLowerCase()\n\n    if (\n      summaryKeywords.some((keyword) => lowerLine.includes(keyword)) &&\n      lowerLine.length < 50\n    ) {\n      // Collect the next few lines as summary\n      let summary = \"\"\n      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {\n        const summaryLine = lines[j].trim()\n        if (summaryLine.length > 10) {\n          summary += (summary ? \" \" : \"\") + summaryLine\n        }\n      }\n      return summary\n    }\n  }\n\n  return \"\"\n}\n\nexport async function parseResumeFromPDF(pdfBuffer: Buffer): Promise<ResumeFormData> {\n  try {\n    // First, extract text from PDF using pdf-parse\n    // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n    const { PDFParse } = require(\"pdf-parse\")\n    \n    let extractedText = \"\"\n    \n    try {\n      const parser = new PDFParse({ data: pdfBuffer })\n      const result = await parser.getText()\n      extractedText = result?.text || \"\"\n    } catch (pdfError) {\n      console.error(\"PDF text extraction failed, will use OpenAI only:\", pdfError)\n    }\n\n    // Use OpenAI to parse and structure the resume data\n    const OpenAI = (await import(\"openai\")).default\n    const openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY,\n    })\n\n    if (!process.env.OPENAI_API_KEY) {\n      // Fallback to regex parsing if OpenAI is not configured\n      if (extractedText) {\n        return extractResumeData(extractedText)\n      }\n      throw new Error(\"OPENAI_API_KEY is not configured. Please set it in your environment variables.\")\n    }\n\n    // Use OpenAI to structure the extracted text\n    if (!extractedText || extractedText.trim().length === 0) {\n      throw new Error(\"Could not extract text from PDF. The PDF might be image-based, password-protected, or corrupted.\")\n    }\n\n    const promptText = `Parse the following resume text and extract structured information. Return a JSON object with this exact structure:\n\n{\n  \"personalInfo\": {\n    \"fullName\": \"string\",\n    \"email\": \"string\",\n    \"phone\": \"string\",\n    \"location\": \"string\",\n    \"linkedIn\": \"string (URL or empty)\",\n    \"portfolio\": \"string (URL or empty)\"\n  },\n  \"professionalSummary\": \"string\",\n  \"workExperience\": [\n    {\n      \"company\": \"string\",\n      \"position\": \"string\",\n      \"startDate\": \"string (YYYY-MM format)\",\n      \"endDate\": \"string (YYYY-MM format or empty)\",\n      \"current\": boolean,\n      \"description\": \"string\"\n    }\n  ],\n  \"education\": [\n    {\n      \"institution\": \"string\",\n      \"degree\": \"string\",\n      \"field\": \"string\",\n      \"graduationDate\": \"string (YYYY-MM format)\"\n    }\n  ],\n  \"skills\": {\n    \"technical\": \"string (comma-separated)\",\n    \"soft\": \"string (comma-separated or empty)\"\n  }\n}\n\nIMPORTANT FORMATTING INSTRUCTIONS:\n- For work experience descriptions: Convert long paragraphs into bullet points. Format each bullet point on a new line starting with \"- \" or \"• \". Break down responsibilities, achievements, and accomplishments into separate bullet points.\n- For professional summary: If the summary is a long paragraph, break it into 2-3 concise bullet points when possible, each on a new line starting with \"- \" or \"• \".\n- Preserve the original meaning and content, but organize it as bullet lists instead of long paragraphs.\n- Each bullet point should be a complete, meaningful statement.\n\nResume text:\n${extractedText}\n\nReturn ONLY valid JSON, no additional text or markdown formatting.`\n\n    // Use OpenAI text API to parse and structure the resume\n    const response = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: [\n        {\n          role: \"user\",\n          content: promptText,\n        },\n      ],\n      response_format: { type: \"json_object\" },\n      max_tokens: 4000,\n    })\n\n    const jsonResponse = response.choices[0]?.message?.content || \"{}\"\n    const parsedData = JSON.parse(jsonResponse)\n    \n    // Transform to match ResumeFormData format\n    return {\n      personalInfo: parsedData.personalInfo || {\n        fullName: \"\",\n        email: \"\",\n        phone: \"\",\n        location: \"\",\n        linkedIn: \"\",\n        portfolio: \"\",\n      },\n      professionalSummary: parsedData.professionalSummary || \"\",\n      workExperience: parsedData.workExperience?.length > 0 ? parsedData.workExperience : [\n        {\n          company: \"\",\n          position: \"\",\n          startDate: \"\",\n          endDate: \"\",\n          current: false,\n          description: \"\",\n        },\n      ],\n      education: parsedData.education?.length > 0 ? parsedData.education : [\n        {\n          institution: \"\",\n          degree: \"\",\n          field: \"\",\n          graduationDate: \"\",\n        },\n      ],\n      skills: {\n        technical: parsedData.skills?.technical || \"\",\n        soft: parsedData.skills?.soft || \"\",\n      },\n    }\n  } catch (error) {\n    console.error(\"Error parsing PDF with OpenAI:\", error)\n    const errorMessage = error instanceof Error ? error.message : String(error)\n    console.error(\"PDF Parse Error Details:\", errorMessage)\n    \n    // Fallback to regex parsing if OpenAI fails\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires\n      const { PDFParse } = require(\"pdf-parse\")\n      const parser = new PDFParse({ data: pdfBuffer })\n      const result = await parser.getText()\n      const text = result?.text || \"\"\n      if (text && text.trim().length > 0) {\n        console.log(\"Falling back to regex parsing\")\n        return extractResumeData(text)\n      }\n    } catch (fallbackError) {\n      console.error(\"Fallback parsing also failed:\", fallbackError)\n    }\n    \n    // Provide more helpful error messages\n    if (errorMessage.includes(\"OPENAI_API_KEY\")) {\n      throw new Error(\"OpenAI API key is not configured. Please set OPENAI_API_KEY in your environment variables.\")\n    } else if (errorMessage.includes(\"empty\") || errorMessage.includes(\"extract text\")) {\n      throw new Error(\"Could not extract text from PDF. The PDF might be image-based, password-protected, or corrupted.\")\n    } else if (errorMessage.includes(\"Invalid PDF\")) {\n      throw new Error(\"Invalid PDF file format. Please ensure the file is a valid PDF.\")\n    } else if (errorMessage.includes(\"rate_limit\") || errorMessage.includes(\"quota\")) {\n      throw new Error(\"OpenAI API rate limit exceeded. Please try again later.\")\n    } else if (errorMessage.includes(\"JSON\")) {\n      throw new Error(\"Failed to parse OpenAI response. Please try again.\")\n    } else {\n      throw new Error(`Failed to parse PDF: ${errorMessage}`)\n    }\n  }\n}\n\n// Extract resume data from text\nfunction extractResumeData(text: string): ResumeFormData {\n  // Extract all information\n  const personalInfo = {\n    fullName: extractName(text),\n    email: extractEmail(text),\n    phone: extractPhone(text),\n    location: extractLocation(text),\n    linkedIn: extractLinkedIn(text),\n    portfolio: extractPortfolio(text),\n  }\n\n  const professionalSummary = extractProfessionalSummary(text)\n  const workExperience = extractWorkExperience(text)\n  const education = extractEducation(text)\n  const skills = extractSkills(text)\n\n  // Return structured data matching ResumeFormData format\n  return {\n    personalInfo,\n    professionalSummary: professionalSummary || \"\",\n    workExperience: workExperience.length > 0 ? workExperience : [\n      {\n        company: \"\",\n        position: \"\",\n        startDate: \"\",\n        endDate: \"\",\n        current: false,\n        description: \"\",\n      },\n    ],\n    education: education.length > 0 ? education : [\n      {\n        institution: \"\",\n        degree: \"\",\n        field: \"\",\n        graduationDate: \"\",\n      },\n    ],\n    skills: {\n      technical: skills.technical || \"\",\n      soft: skills.soft || \"\",\n    },\n  }\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"sources":["file:///Users/viveks/PycharmProjects/resume-builder/src/app/api/resumes/parse-pdf/route.ts"],"sourcesContent":["import { auth } from \"@clerk/nextjs/server\"\nimport { NextResponse } from \"next/server\"\nimport { parseResumeFromPDF } from \"@/lib/parse-resume-from-pdf\"\n\nexport async function POST(request: Request) {\n  try {\n    const authResult = await auth()\n    const userId = authResult?.userId\n    \n    if (!userId) {\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 })\n    }\n\n    const formData = await request.formData()\n    const file = formData.get(\"file\") as File\n\n    if (!file) {\n      return NextResponse.json({ error: \"No file provided\" }, { status: 400 })\n    }\n\n    // Validate file type\n    if (file.type !== \"application/pdf\") {\n      return NextResponse.json(\n        { error: \"Only PDF files are supported\" },\n        { status: 400 }\n      )\n    }\n\n    // Validate file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      return NextResponse.json(\n        { error: \"File size must be less than 10MB\" },\n        { status: 400 }\n      )\n    }\n\n    // Convert File to Buffer\n    const arrayBuffer = await file.arrayBuffer()\n    const buffer = Buffer.from(arrayBuffer)\n\n    // Validate buffer is not empty\n    if (!buffer || buffer.length === 0) {\n      return NextResponse.json(\n        { error: \"Invalid PDF file: file appears to be empty\" },\n        { status: 400 }\n      )\n    }\n\n    // Parse the PDF\n    const parsedData = await parseResumeFromPDF(buffer)\n\n    return NextResponse.json(parsedData)\n  } catch (error) {\n    console.error(\"Error parsing PDF:\", error)\n    const errorMessage = error instanceof Error ? error.message : \"Unknown error\"\n    console.error(\"Full error:\", error)\n    \n    return NextResponse.json(\n      { \n        error: \"Failed to parse PDF. Please ensure it's a valid resume PDF.\",\n        details: process.env.NODE_ENV === \"development\" ? errorMessage : undefined\n      },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,aAAa,MAAM,IAAA,6LAAI;QAC7B,MAAM,SAAS,YAAY;QAE3B,IAAI,CAAC,QAAQ;YACX,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpE;QAEA,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAmB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,qBAAqB;QACrB,IAAI,KAAK,IAAI,KAAK,mBAAmB;YACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+B,GACxC;gBAAE,QAAQ;YAAI;QAElB;QAEA,gCAAgC;QAChC,IAAI,KAAK,IAAI,GAAG,KAAK,OAAO,MAAM;YAChC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,SAAS,OAAO,IAAI,CAAC;QAE3B,+BAA+B;QAC/B,IAAI,CAAC,UAAU,OAAO,MAAM,KAAK,GAAG;YAClC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA6C,GACtD;gBAAE,QAAQ;YAAI;QAElB;QAEA,gBAAgB;QAChB,MAAM,aAAa,MAAM,IAAA,oKAAkB,EAAC;QAE5C,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,sBAAsB;QACpC,MAAM,eAAe,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC9D,QAAQ,KAAK,CAAC,eAAe;QAE7B,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,uCAAyC,eAAe;QACnE,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}